# 式
- 終わりに;を付ける

## オブジェクト
- 文字
  - 文字(char)
  - 文字列(char[])
```c
'a';
"abc";
```

## 関数呼び出し
```c
関数名(引数) ... ;
printf("HelloWorld");
```

# 定義
## ライブラリの読み込み
```c
#include <ライブラリ名>
```

## 関数
- コンパイラ型言語は、メイン関数の前にプロトタイプ宣言が必要
- 引数は、`データ型 引数名`で渡して、区切りは`,``
  - 戻り値や引数がない場合は、voidを指定する
- 仮引数の変数名は省略可能
```c
戻り値のデータ型 関数名(仮引数); /*プロトタイプ宣言*/


戻り値のデータ型 関数名 (引数, ..) {
  処理;
  return 戻り値;
}
```

## 変数(と初期化)
- 同じデータ型なら,で区切って複数宣言できる
- ローカル変数は初期値を指定する必要がある(ただし、gccは自動で0で初期化してくれる)
```c
(変数オプション) データ型 変数名;
int num; /* num = 0 */
static int num;

int i, y;
int i, y = 1;
```

## 配列
- 初期値の要素を代入する際は、要素数を省略可能
- c言語にはGCがないので、メモリを複数消費する配列は、使い終わったら必ずfree関数で開放する
```c
データ型 配列名[要素数];
データ型 配列名[要素数] = {要素};
```


# 条件分岐
- 複数行処理を書く際、endはなくブロックで囲う点に注意

## if
```c
if (条件式) 処理;
if (条件式) {
  処理;
}

if (式) {
  if処理;
} else if (条件式) {
  elsif処理;
} else {
  else処理;
}
```

## switch(case)
- case ~ / ~ when ~ではなく、switch ~ / case: ~  ~
- breakを書かないと抜け出せない
  - switch文がそもそもcaseにジャンプさせるだけの構文のため
- 最後はelseではなくdefault:
- case 値:を連続で書くことで、複数条件を表現出来る
  - breakがないとそのまま処理されるため
```c
switch (条件式) {
  case 値:
    処理;
    break;
  case 値:
  case 値2:
    処理;
    break;
    ...
  default:
}
```

# ループ処理
- 条件文同様、endはなくブロックで囲う点に注意

## for
- for文の引数は全て省略可能
  - その場合、条件式は常に真になる
- カウンタ変数の初期化は、既にある関数を使っても新たに定義してもいい
- 更新処理にはどんな式も記述可能
  - しかし、カウンタの更新以外の式を記述するのは分かりづらいだけ
- breakが使える
```c
for (初期化; 条件式; 更新) {
  処理;
}

for (int i = 0; i < 6; i++) {
  printf("%d\n", i);
}
```

## while
- 引数省略不可
- 先判定
  ```c
  while (条件式) {
    処理;
  }
  ```

- 後判定
  - 特定の条件の場合のみ繰り返したい処理をdo whileで囲うといい感じに使える
  ```c
  do {
    処理;
  } while (条件式)
  ```