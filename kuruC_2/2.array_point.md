# 配列
- c言語の配列は、起点のアドレスから、指定したデータ型 * 要素数分を、関数内で予約するだけの機能
- 配列は引数で渡せない(構造体の時を除く)、引数で渡す場合は[0]のアドレスを、ポインタ変数に渡す
  - この際のポインタ変数の[1]以降を参照した時、配列の要素内であればセグメフォは起きない
  - ただし、sizeofなどの関数は使えない
- c言語にはGCがないので、メモリを複数消費する配列は、使い終わったら必ずfree関数で開放する

## 構文
- 初期値の要素を代入する際は、要素数を省略可能 
- 初期値の記入には{}を使う
```c
/* 定義 */
データ型 配列名[要素数];
データ型 配列名[要素数] = {要素};

/* 呼び出し */
配列名[番号];

```

## 応用
- `sizeof(配列名)`で要素のアドレス数を求められる
  - `sizeof(配列名)/sizeof(配列名[0])`で配列サイズを求められる
  - 以下のようにして、rubyのeachを実現できる
  ```c
  array_size = sizeof(array) / sizeof (array[0])
  for (i = 0; i < array_size; i++) {
    array[i] ~ ;
  }
  ```
- sizeof[0] * n で、先頭からn子分の要素を指定できる

## 動的配列
### 任意の数の配列を作成
- malloc関数: malloc(byte数)
- 起点はポインタで良い
- メモリの確保に失敗した場合、NULLを返す
```c
n = 増やす要素数
ポインタ = (データ型 *)malloc(sizeof(データ型) * n)
if (ポインタ == NULL) exit(0); /*ブログラムを終了*/
```

### 既存の配列のサイズを変更
- realloc関数: realloc(以前のポインタ, バイトサイズ) 

## free
- メモリの予約を解除する(メモリを開放する)
- 配列以外にも使用可能
- free関数: free(配列の起点)


## 配列の関数
|ライブラリ|関数名|引数|説明|
| ---- | ---- | ---- | ----|
| memory.h | memcpy | コピー先, コピー元, 配列のサイズ | 配列のコピー
| string.h | strcpy | コピー先, コピー元 | 文字列のコピー


# ポインタ
## 変数のアドレス
- &を変数に付けると、変数のアドレスを出力する
- Rubyとは変数の仕組みがそもそも違う
  - C言語の変数: アドレスと変数を直接結びつけて固定する、変数に値を代入すると、そのアドレスのメモリの中身が書き変わる
  - Rubyの変数: オブジェクトのidと変数を結び付ける、変数に値を代入すると、新たにその値(オブジェクト)のメモリを確保してそこにオブジェクトを生成、そして変数の参照先を、生成したオブジェクトのidに書き換える
  - つまり、Cの代入はメモリ内データの書き換え、Rubyの代入は変数の参照先の変更

## 配列と文字列のアドレス
- array は &array[0] を指している

## ポインタ型 / ポインタ変数
### 概要
- 元のデータ型 + ポインタ型を指定 = ポインタ型
- ポインタ型の変数は、ポインタ変数モードと、通常の変数モードがある
  - ポインタ変数モードは、参照渡し等、アドレス事態を受け取る or 受け渡す時に使われる
  - そして、メモリの値を参照したいときは、通常変数モードを使って、値の読み書きを行う
- 定義時には、変数の前に*を付ける
- `ポインタ変数モード`: *なし, `通常モード`: *あり

### 文法
```c
/*定義*/
int *p;

/*アドレスを代入*/
int i;
p = &i;

/*アドレスモード*/
p //=> メモリのアドレスを返す

/*通常モード*/
*p //=> メモリの中身を返す
*p += 2;
```

## ポインタと配列
### ポインタ変数と配列変数の違い
- ポインタ変数: 好きな変数のアドレスを補完する、そこに配列変数も含まれる
- 配列変数: 複数の変数の先頭のアドレスを補完する変数

### ポインタ演算
- 配列の[0]の値をポインタ変数に渡すと、ポインタ変数自体が配列名のように振舞う
- `配列[0]のポインタ変数 + 番号n`: 上の方式で渡したポインタの演算
  - ポインタのアドレスを配列要素n個分進めるということ
  - これは配列[0]のアドレスではないポインタ変数にも使えるが、セグメフォが起こる
```c
/*配列のように振舞うポインタ変数*/
int *p, array[3] = {1,2,3}
p = array; //array[0]のアドレスをpに渡す
p[1] == 2;
*(p + 1) == 2;

/*ポインタ演算を利用した参照*/
int *p, array[3] = {1,2,3}
for (p = array; p != &array[10]; p++) {
  printf("%d\n", *p);
}

```


## 参照渡し
- 上の定義の例で、ポインタ変数と通常変数のアドレスを結び付けていた
  - それを引数で行うことで、参照渡しが実現できる
```c

int i = 5;
function_1(&i);

/*引数のポインタ変数p(int *p)と、呼び出し元の関数のiのアドレス(&i)を結び付けている*/
void function_1 (int *p) {
  *p == 呼び出し元のi として処理できる
}
```

- また、配列を受け取る引数を定義する場合、記述は以下のどれでも可能
  - `*arg`, `arg[]`, `arg[要素数]`
  - art[]が推奨される

